use ::crypto;
use ::crypto::hmac::Hmac;
use ::crypto::mac::Mac;
use ::crypto::sha1::Sha1;
use ::actix_web::http::header::{HeaderMap, HeaderValue};
use ::actix_web::*;
use ::hex;
use ::log::{warn, info};

use crate::settings::Settings;

type HmacSha1 = Hmac<Sha1>;

pub fn verify_authentication_header(
    settings: &Settings,
    request: &HttpRequest,
    body: &web::Bytes,
    parsed_body: String,
) -> Result<(), HttpResponse> {
    // Check whether need both methods for authorization to work
    let check_both = settings.basic_auth_and_secret;

    // Extract the existing secret from the settings
    let secret = settings.secret.clone().unwrap_or_default();
    let has_secret = !secret.is_empty();

    // Check whether we have basic auth
    let user = settings.basic_auth_user.clone().unwrap_or_default();
    let password = settings.basic_auth_password.clone().unwrap_or_default();
    let has_basic_auth = !user.is_empty() && !password.is_empty();

    // We don't need any authentication, return early
    if !has_secret && !has_basic_auth {
        return Ok(());
    }

    // Check for a correct signature, if we have as secret or both authentication methods are required
    if has_secret || check_both {
        let signature = get_signature_header(&request.headers())?;
        if !signature.is_empty() {
            verify_signature_header(signature, secret, body, parsed_body)?;
        } else if check_both {
            // The signature header is required and couldn't be found
            return Err(HttpResponse::Unauthorized().body("No signature header found"));
        }
    }

    Ok(())
}

/// Extract the correct signature header content from all headers
/// It's possible to receive the signature from multiple Headers, since Github uses their own
/// Header name for their signature method.
fn get_signature_header(headers: &HeaderMap) -> Result<String, HttpResponse> {
    let header: &HeaderValue;
    if headers.contains_key("signature") {
        header = headers
            .get("signature")
            .expect("Error while extracting signature header");
    } else if headers.contains_key("X-Hub-Signature") {
        header = headers
            .get("X-Hub-Signature")
            .expect("Error while extracting github signature header");
    } else {
        // We dont' find any headers for signatures and this method is not required
        return Ok("".to_string());
    };

    match header.to_str() {
        Ok(header) => {
            // Header must be formatted like this: sha1={{hash}}
            let mut header = header.to_string();
            if !header.starts_with("sha1=") {
                Err(HttpResponse::Unauthorized()
                    .body("Error while parsing signature: Couldn't find prefix"))
            } else {
                Ok(header.split_off(5))
            }
        },
        Err(error) => {
            Err(HttpResponse::Unauthorized()
                .body(format!("Error while parsing signature: {}", error)))
        }
    }
}


/// Verify the signature header. Checks our own signature generated by hmac sha1 with secret and payload
/// against the signature provided in the header.
fn verify_signature_header(signature: String, secret: String, body: &web::Bytes, parsed_body: String) -> Result<(), HttpResponse> {
    // Try to decode the sha1 into bytes. Should be a valid hex string
    let signature_bytes = match hex::decode(&signature) {
        Ok(result) => result,
        Err(error) => {
            warn!("Error decoding signature: {}, {}", signature, error);
            return Err(HttpResponse::Unauthorized().body("Invalid sha1 signature"));
        }
    };

    // Generate the own hmac sha1 from the secret and body and verify that it's identical to the signature
    let secret_bytes = match hex::decode(secret) {
        Ok(secret_bytes) => secret_bytes,
        Err(_) => panic!("Invalid secret. This cannot happen."),
    };
    let expected_signature = generate_signature_sha1(&secret_bytes, body).result();

    let valid = crypto::util::fixed_time_eq(expected_signature.code(), &signature_bytes);
    if !valid {
        info!("Our sha1: {}", hex::encode(expected_signature.code()));
        warn!("Got wrong sha1: {}\nWith payload: {}", signature, parsed_body);
        return Err(HttpResponse::Unauthorized().body("Invalid sha1 signature"));
    }

    Ok(())
}

/// Create a hmac SHA1 instance from a secret and body
fn generate_signature_sha1(secret_bytes: &Vec<u8>, body: &web::Bytes) -> Hmac<Sha1> {
    let digest = Sha1::new();
    let mut hmac = Hmac::new(digest, secret_bytes);
    hmac.input(body);

    hmac
}
